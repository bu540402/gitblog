title: c++基础：指针与引用
date: 2016-04-23 15:38:36
tags: [c++,c,编程语言]
---
# c++基础：指针与引用
[TOC]
## 引用

### 引用基础

普通的引用通常是指左值引用。引用（reference）为对象起了另一个名字，引用类型引用另一种类型。引用类型并非对象，相反的，它只是为一个已经存在的对象所起的另一个名字。定义引用时，程序把引用和他的初始值绑定（bind）在一起。引用是必须会被初始化的，而且不能再将引用绑定在另一个对象上。

> 1. ** 引用并非对象，所以不能定义引用的引用。**
1. ** 非常量引用只能绑定在对象上，而不能绑定字面指或者表达式结果。**
1. **不要返回局部对象的引用或者指针，因为函数完成后他所占用的存储空间也会随之释放，因为局部变量的引用将指向不再有效的内存区域**

### 常量引用
常量引用是对const的引用。对常量的引用不能被用作修改它所绑定的对象。
> 1. 非常量引用不能引用一个常量对象
> 2. 常量引用可以引用常量对象也可以引用普通对象
> 3. **常量引用可以绑定字面指或者表达式结（因为这些值也是常量）**
```
//以下合法
const int& refExpression=10*5.012;
```

### 右值引用
函数的返回类型决定函数调用是否为左值，调用一个返回引用的函数得到左值，其他类型得到右值。例如可以这样
```
char &getVal(){};
getVal()='F';
```
等待更新

## 指针

### 指针基础

指针是用来存储地址的变量。他是指向另一种类型的复合类型。** 指针本身就是一个对象，允许对指针赋值和拷贝。在其声明周期内可以指向不同的对象**。指针无需再定义时赋值，没有被初始化的指针拥有一个不确定的值。
```
  //声明指针的两种形式
  int *p,*q;
  int* p;
  int* q;
```
> 1. ** 初始化所有的指针，未初始化的指针可能会引起程序运行时错误 。**
> 2. ** void*指针可以存放任意对象的指针但是无法访问其指向的内存空间的内容 。使用static_cast 可以将void* 转换成原有的类型指针，如果类型不符合将产生未定义的后果**

### 指针常量
指针常量是指向常量的指针。不能用于改变其所值得对象的值。常量对象只能用指针常量来指向。  
```
const int a=10;
const int *p=&a;
```
> 1. ** 指针常量允许指向一个非常量对象。**
> 1. ** 指针常量的指向是可以更改的，可以指向其他帝乡。**

### 常量指针
指针本身是一个对象，如果指针被声明为常量指针，该指针本身是一个常量，一旦指定一个对象不能再做更改。
```
int a=10;
int *const p=&a;//p不能再指向其他对象，可以通过p改变a
const int b2=20;
const int *const q=&b2;//q本身是指向一个常量的常量指针。不能通过q改变对象，q的指向也不能改变。
```
### 函数指针

## 指针与引用的对比
### 顶层const与底层const
顶层const 表示指针本身是常量
底层const 表示指针所指的对象是常量
### 指针与引用的优劣
- *指针可以为空或者未初始化的状态而引用必须初始化，从这个角度来讲指针比引用更危险。*
- *通过指针new出来的空间必须delete才能释放掉。可能会造成内存泄漏*
- *通过引用来传递参数,可以减少对象的复制，增强效率*

### 指针和引用作为函数参数分别适用于什么情况

### 指向指针的引用
指针的引用，相当于一个指针。保持和原来指针一样的属性。然后似乎并没有指向引用的指针。

```
int main()
{

	int str=10;
	const int dataA=10;
	const int* dataPrtA=&dataA;

	const int dataB=20;
	const int* dataPrtB=&dataB;

	const int* &dataRef=dataPrtA;

	cout<<*dataRef<<endl;
	dataRef=dataPrtB;
	cout<<*dataRef<<endl;
	return 0;
}

```
